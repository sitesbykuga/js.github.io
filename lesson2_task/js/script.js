// ----- Задача 1 ----- 
let x = 5; 

/* Задаем число, в алерте увеличиваем его на 1, 
но используем префиксную форму. x увеличится, но потом. 
Выведем его в консоль, для проверки*/

console.log( 'Задача 1: '+ x++ + ' -> ' + x ); 

// ----- Задача 2 ----- 

x = [ ] + false - null + true ;
/*null преобразует тип выражения в number. 
Сам null тогда принимает значение 0. 
Массив обычно принимает тип строки, но если пустой массив + null - будет число (0).
В данном примере порядок операций такой, что [ ] + false дает строку 'false'.
Из такой строки вычитаем null. Получаем число (NaN).
Прибавление true уже ни на что не влияет.
Но если преобразовать выражение в  [ ] - null + true + false, то получим 1. (true даст 1)*/
console.log( 'Задача 2: ' + typeof(x) + ' ' + x );


// ----- Задача 3 ----- 

 let y = 1; 
 x = y = 2; 
 //alert(x);

 /*Сначала 2 присваевается y, потом x. => y = 2, x = 2*/
 console.log( 'Задача 3: x = ' + x + ', y = ' + y );

// ----- Задача 4 ----- 

x = [ ] + 1 + 2;
/*Происходит преобразование типа в string. Получится строка '12' */
console.log( 'Задача 4: ' + x );

// ----- Задача 5 ----- 

console.log( 'Задача 5: ' + "1"[0] );
/*0 - индекс символа в стркое "1".
Конструкция "13"[1] даст 3 */

// ----- Задача 6 ----- 

/*Короткий цикл вычислений. 
Вычисления слево направо, если аргумент — false, 
оператор && возвращает его и заканчивает вычисления. 
Иначе — вычисляет дальше, если false в списке нет, 
возвращает последний правый аргумент, а он будет true.
2 - true
1 - true
null - false
0 - false
undefined - false
Результат: null
*/
console.log( 'Задача 6: ' + (2 && 1 && null && 0 && undefined) );

// ----- Задача 7 -----

let a = 3,
	b = 5;
x =  !!( a && b ); 
y = (a && b);
/*!! - специальный трюк для получения  в 100% случаях boolen 
Во втором случае может на выходе сработать короткий цикл вычислений
 и мы получим значение a или b*/

console.log( 'Задача 7: x = ' + x + ', y = ' + y );

// ----- Задача 8 -----

/*Приоритет у И выше, порядок операций будет следующим:
2 && 3 => 3
null || 3 => 3 (первое true)
3 || 4 => 4 */

console.log( 'Задача 8: ' +  (null || 2 && 3 || 4) );

// ----- Задача 9 -----

a = [1, 2, 3]; 
b = [1, 2, 3]; 

/*Массивы, как объекты, имеют ссылочный тип данных. 
Т.е. при присваивании одной переменной другой передается 
ссылка на данные, а не сами данные. Соответственно, в дальнейшем,
при изменении какой-либо переменной в одном массиве, эта переменная
изменится и в другом. Получаем, что два отдельных объекта никогда 
не будут равными, даже если они имеют равный набор свойств. 
Только сравнение двух ссылок на один и тотже объект вернет true. */
console.log( 'Задача 9: ' +  (a == b)); //false

// ----- Задача 10 -----

/*Infinity - это число. Знак + перед строкой говорит о преобразовании 
строки в число. В результате получим Infinity*/

console.log( 'Задача 10: ' + +"Infinity" );

// ----- Задача 11 -----

/*Строки можно сравнивать. Сравнение идет от символа к символу
в алфавитном порядке, где 'а' > 'я'.
Т.к. 'ё' > 'я', то получим true*/

console.log( 'Задача 11: ' + ("ёжик" > "яблоко"));

// ----- Задача 12 -----

/*Как и в задаче 6 - короткий цикл вычислений. 
Только теперь с оператором ИЛИ.
Соответственно, выведет первое true или последнее false. 
В данном примере получим 2 */

console.log( 'Задача 12: ' + (0 || "" || 2 || undefined || true || falsе) );




